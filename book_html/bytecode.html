<p>^title Bytecode ^section Behavioral Patterns</p>
<h2 id="intent">Intent</h2>
<p><em>Give behavior the flexibility of data by encoding it as instructions for a virtual machine.</em></p>
<h2 id="motivation">Motivation</h2>
<p>Making games may be fun, but it certainly ain't easy. Modern games require <span name="sprawling">enormous</span>, complex codebases. Console manufacturers and app marketplace gatekeepers have stringent quality requirements, and a single crash bug can prevent your game from shipping.</p>
<aside name="sprawling">
<p>I worked on a game that had six million lines of C++ code. For comparison, the software controlling the Mars Curiosity rover is less than half that.</p>
</aside>
<p>At the same time, we're expected to squeeze every drop of performance out of the platform. Games push hardware like nothing else, and we have to optimize relentlessly just to keep pace with the competition.</p>
<p>To handle these high stability and performance requirements, we reach for heavyweight languages like C++ that have both low-level expressiveness to make the most of the hardware and rich type systems to prevent or at least corral bugs.</p>
<p>We pride ourselves on our skill at this, but it has its cost. Being a proficient programmer takes years of dedicated training, after which you must contend with the sheer scale of your codebase. Build times for large games can vary somewhere between &quot;go get a coffee&quot; and &quot;go roast your own beans, hand-grind them, pull an espresso, foam some milk, and practice your latte art in the froth&quot;.</p>
<p>On top of these challenges, games have one more nasty constraint: <em>fun</em>. Players demand a play experience that's both novel and yet carefully balanced. That requires constant iteration, but if every tweak requires bugging an engineer to muck around in piles of low-level code and then waiting for a glacial recompile, you've killed your creative flow.</p>
<h3 id="spell-fight">Spell fight!</h3>
<p>Let's say we're working on a magic-based fighting game. A pair of wizards square off and fling enchantments at each other until a victor is pronounced. We could define these spells in code, but that means an engineer has to be involved every time one is modified. When a designer wants to tweak a few numbers and get a feel for them, they have to recompile the entire game, reboot it, and get back into a fight.</p>
<p>Like most games these days, we also need to be able to update the game after it ships, both to fix bugs and to add new content. If all of these spells are hard-coded, then updating them means patching the actual game executable.</p>
<p>Let's take things a bit further and say that we also want to support <em>modding</em>. We want <em>users</em> to be able to create their own spells. If those are in code, that means every modder needs a full compiler toolchain to build the game, and we have to release the sources. Worse, if they have a bug in their spell, it can crash the game on some other player's machine.</p>
<h3 id="data-code">Data &gt; code</h3>
<p>It's pretty clear that our engine's implementation language isn't the right fit. We need spells to be safely sandboxed from the core game. We want them to be easy to modify, easy to reload, and physically separate from the rest of the executable.</p>
<p>I don't know about you, but to me that sounds a lot like <em>data</em>. If we can define our behavior in separate data files that the game engine loads and &quot;executes&quot; in some way, we can achieve all of our goals.</p>
<p>We just need to figure out what &quot;execute&quot; means for data. How do you make some bytes in a file express behavior? There are a few ways to do this. I think it will help you get a picture of <em>this</em> pattern's strengths and weaknesses if we compare it to another one: the <a
href="http://en.wikipedia.org/wiki/Interpreter_pattern"
class="gof-pattern">Interpreter</a> pattern.</p>
<h3 id="the-interpreter-pattern">The Interpreter pattern</h3>
<p>I could write a whole chapter on this pattern, but four other guys already covered that for me. Instead, I'll cram the briefest of introductions in here. It starts with a language -- think <em>programming</em> language -- that you want to execute. Say, for example, it supports arithmetic expressions like this:</p>
<pre><code>(1 + 2) * (3 - 4)</code></pre>
<p>Then, you take each piece of that expression, each rule in the language's grammar, and turn it into an <em>object</em>. The number literals will be objects:</p>
<p><img src="images/bytecode-numbers.png" alt="A series of number literal objects." /></p>
<p>Basically, they're little wrappers around the raw value. The operators will be objects too, and they'll have references to their operands. If you take into account the parentheses and precedence, that expression <span name="magic">magically</span> turns into a little tree of objects like so:</p>
<p><img src="images/bytecode-ast.png" alt="A syntax tree. The number literals are connected by operator objects." /></p>
<aside name="magic">
<p>What &quot;magic&quot; is this? It's simple -- <em>parsing</em>. A parser takes a string of characters and turns it into an <em>abstract syntax tree</em>, a collection of objects representing the grammatical structure of the text.</p>
<p>Whip up one of these and you've got yourself half of a compiler.</p>
</aside>
<p>The Interpreter pattern isn't about <em>creating</em> that tree; it's about <em>executing</em> it. The way it works is pretty clever. Each object in the tree is an expression or a subexpression. In true object-oriented fashion, we'll let expressions evaluate themselves.</p>
<p>First, we define a base interface that all expressions implement:</p>
<p>^code expression</p>
<p>Then, we define a class that implements this interface for each kind of expression in our language's grammar. The simplest one is numbers:</p>
<p>^code number</p>
<p>A literal number expression simply evaluates to its value. Addition and multiplication are a bit more complex because they contain subexpressions. Before they can evaluate themselves, they need to recursively evaluate their subexpressions. Like so:</p>
<p><span name="addition"></span></p>
<p>^code addition</p>
<aside name="addition">
<p>I'm sure you can figure out what the implementation of multiply looks like.</p>
</aside>
<p>Pretty neat right? Just a couple of simple classes and now we can represent and evaluate arbitrarily complex arithmetic expressions. We just need to create the right objects and wire them up correctly.</p>
<aside name="ruby">
<p>Ruby was implemented like this for something like 15 years. At version 1.9, they switched to bytecode like this chapter describes. Look how much time I'm saving you!</p>
</aside>
<p>It's a <span name="ruby">beautiful</span>, simple pattern, but it has some problems. Look up at the illustration. What do you see? Lots of little boxes, and lots of arrows between them. Code is represented as a sprawling fractal tree of tiny objects. That has some unpleasant consequences:</p>
<ul>
<li><p>Loading it from disk requires instantiating and wiring up tons of these small objects.</p></li>
<li><p>Those objects and the pointers between them use a lot of <span name="vtable">memory</span>. On a 32-bit machine, that little arithmetic expression up there takes up at least 68 bytes, not including padding.</p>
<aside name="vtable">
<p>If you're playing along at home, don't forget to take into account the vtable pointers.</p>
</aside></li>
<li><p>Traversing the pointers into subexpressions is murder on your <span name="cache">data cache</span>. Meanwhile, all of those virtual method calls wreak carnage on your instruction cache.</p>
<aside name="cache">
<p>See the chapter on <a href="data-locality.html" class="pattern">Data Locality</a> for more on what the cache is and how it affects your performance.</p>
</aside></li>
</ul>
<p>Put those together, and what do they spell? S-L-O-W. There's a reason most programming languages in wide use aren't based on the Interpreter pattern. It's just too slow, and it uses up too much memory.</p>
<h3 id="machine-code-virtually">Machine code, virtually</h3>
<p>Consider our game. When we run it, the player's computer doesn't traverse a bunch of C++ grammar tree structures at runtime. Instead, we compile it ahead of time to machine code, and the CPU runs that. What's machine code got going for it?</p>
<ul>
<li><p><em>It's dense.</em> It's a solid, contiguous blob of binary data, and no bit goes to waste.</p></li>
<li><p><em>It's linear.</em> Instructions are packed together and executed one right after another. No jumping around in memory (unless you're doing actual control flow, of course).</p></li>
<li><p><em>It's low-level.</em> Each instruction does one relatively minimal thing, and interesting behavior comes from <em>composing</em> them.</p></li>
<li><p><em>It's fast.</em> As a consequence of all of these (well, and the fact that it's implemented directly in hardware), machine code runs like the wind.</p></li>
</ul>
<p>This sounds swell, but we don't want actual machine code for our spells. Letting users provide machine code which our game executes is just begging for <span name="jit">security problems</span>. What we need is a compromise between the performance of machine code and the safety of the Interpreter pattern.</p>
<p>What if instead of loading actual machine code and executing it directly, we defined our own <em>virtual</em> machine code? We'd then write a little emulator for it in our game. It would be similar to machine code -- dense, linear, relatively low-level -- but would also be handled entirely by our game so we could safely sandbox it.</p>
<aside name="jit">
<p>This is why many game consoles and iOS don't allow programs to execute machine code loaded or generated at runtime. That's a drag because the fastest programming language implementations do exactly that. They contain a &quot;just-in-time&quot; compiler, or <em>JIT</em>, that translates the language to optimized machine code on the fly.</p>
</aside>
<p>We'd call our little emulator a <span name="virtual"><em>virtual machine</em></span> (or &quot;VM&quot; for short), and the synthetic binary machine code it runs <em>bytecode</em>. It's got the flexibility and ease of use of defining things in data, but it has better performance than higher-level representations like the Interpreter pattern.</p>
<aside name="virtual">
<p>In programming language circles, &quot;virtual machine&quot; and &quot;interpreter&quot; are synonymous, and I use them interchangeably here. When I refer to the Gang of Four's Interpreter pattern, I'll use &quot;pattern&quot; to make it clear.</p>
</aside>
<p>This sounds daunting, though. My goal for the rest of this chapter is to show you that if you keep your feature list pared down, it's actually pretty approachable. Even if you end up not using this pattern yourself, you'll at least have a better understanding of Lua and many other languages which are implemented using it.</p>
<h2 id="the-pattern">The Pattern</h2>
<p>An <strong>instruction set</strong> defines the low-level operations that can be performed. A series of instructions is encoded as a <strong>sequence of bytes</strong>. A <strong>virtual machine</strong> executes these instructions one at a time, using a <strong>stack for intermediate values</strong>. By combining instructions, complex high-level behavior can be defined.</p>
<h2 id="when-to-use-it">When to Use It</h2>
<p>This is the most complex pattern in this book, and it's not something to throw into your game lightly. Use it when you have a lot of behavior you need to define and your game's implementation language isn't a good fit because:</p>
<ul>
<li><p>It's too low-level, making it tedious or error-prone to program in.</p></li>
<li><p>Iterating on it takes too long due to slow compile times or other tooling issues.</p></li>
<li><p>It has too much trust. If you want to ensure the behavior being defined can't break the game, you need to sandbox it from the rest of the codebase.</p></li>
</ul>
<p>Of course, that list describes a bunch of your game. Who doesn't want a faster iteration loop or more safety? However, that doesn't come for free. Bytecode is slower than native code, so it isn't a good fit for performance-critical parts of your engine.</p>
<h2 id="keep-in-mind">Keep in Mind</h2>
<p>There's something <span name="seductive">seductive</span> about creating your own language or system-within-a-system. I'll be doing a minimal example here, but in the real world, these things tend to grow like vines.</p>
<aside name="seductive">
<p>For me, game development is seductive in the same way. In both cases, I'm striving to create a virtual space for others to play and be creative in.</p>
</aside>
<p>Every time I see someone define a little language or a scripting system, they say, &quot;Don't worry, it will be tiny.&quot; Then, inevitably, they add more and more little features until it's a full-fledged <span name="template">language</span>. Except, unlike some other languages, it grew in an ad-hoc, organic fashion and has all of the architectural elegance of a shanty town.</p>
<aside name="template">
<p>For example, see every templating language ever.</p>
</aside>
<p>Of course, there's nothing <em>wrong</em> with making a full-fledged language. Just make sure you do so deliberately. Otherwise, be very careful to control the scope of what your bytecode can express. Put a short leash on it before it runs away from you.</p>
<h3 id="youll-need-a-front-end">You'll need a front-end</h3>
<p>Low-level bytecode instructions are great for performance, but a binary bytecode format is <em>not</em> what your users are going to author. One reason we're moving behavior out of code is so that we can express it at a <em>higher</em> level. If C++ is too low-level, making your users effectively write in <span name="assembly">assembly language</span> -- even one of your own design -- isn't an improvement!</p>
<aside name="assembly">
<p>Challenging that assertion is the venerable game <a href="http://en.wikipedia.org/wiki/RoboWar">RoboWar</a>. In that game, <em>players</em> write little programs to control a robot in a language very similar to assembly and the kind of instruction sets we'll be discussing here.</p>
<p>It was my first introduction to assembly-like languages.</p>
</aside>
<p>Much like the Gang of Four's Interpreter pattern, it's assumed that you also have some way to <em>generate</em> the bytecode. Usually, users author their behavior in some higher-level format, and a tool translates that to the bytecode that our virtual machine understands. In other words, a compiler.</p>
<p>I know, that sounds scary. That's why I'm mentioning it here. If you don't have the resources to build an authoring tool, then bytecode isn't for you. But as we'll see later, it may not be as bad as you think.</p>
<h3 id="youll-miss-your-debugger">You'll miss your debugger</h3>
<p>Programming is hard. We know what we want the machine to do, but we don't always communicate that correctly -- we write bugs. To help find and fix those, we've amassed a pile of tools to understand what our code is doing wrong, and how to right it. We have debuggers, static analyzers, decompilers, etc. All of those tools are designed to work with some existing language: either machine code or something higher level.</p>
<p>When you define your own bytecode VM, you leave those tools behind. Sure, you can step through the VM in your debugger, but that tells you what the VM <em>itself</em> is doing, and not what the bytecode it's interpreting is up to. It certainly doesn't help you map that bytecode back to the high-level form it was compiled from.</p>
<p>If the behavior you're defining is simple, you can scrape by without too much tooling to help you debug it. But as the scale of your content grows, plan to invest real time into features that help users see what their bytecode is doing. Those features might not <span name="debugger">ship</span> in your game, but they'll be critical to ensure that you actually <em>can</em> ship your game.</p>
<aside name="debugger">
<p>Of course, if you want your game to be moddable, then you <em>will</em> ship those features, and they'll be even more important.</p>
</aside>
<h2 id="sample-code">Sample Code</h2>
<p>After the previous couple of sections, you might be surprised how straightforward the implementation is. First, we need to craft an instruction set for our VM. Before we start thinking about bytecode and stuff, let's just think about it like an API.</p>
<h3 id="a-magical-api">A magical API</h3>
<p>If we were defining spells in straight C++ code, what kind of API would we need for that code to call into? What are the basic operations in the game engine that spells are defined in terms of?</p>
<p>Most spells ultimately change one of the stats of a wizard, so we'll start with a couple for that:</p>
<p>^code magic-api</p>
<p>The first parameter identifies which wizard is affected, say <code>0</code> for the player's and <code>1</code> for their opponent. This way, healing spells can affect the player's own wizard, while damaging attacks harm their nemesis. These three little methods cover a surprisingly wide variety of magical effects.</p>
<p>If the spells just silently tweaked stats, the game logic would be fine, but playing it would bore players to tears. Let's fix that:</p>
<p>^code magic-api-fx</p>
<p>These don't affect gameplay, but they crank up the intensity of the gameplay <em>experience</em>. We could add more for camera shake, animation, etc., but this is enough to get us started.</p>
<h3 id="a-magical-instruction-set">A magical instruction set</h3>
<p>Now let's see how we'd turn this <em>programmatic</em> API into something that can be controlled from data. Let's start small and then we'll work our way up to the whole shebang. For now, we'll ditch all of the parameters to these methods. We'll say the <code>set___()</code> methods always affect the player's own wizard and always max out the stat. Likewise, the FX operations always play a single hard-coded sound and particle effect.</p>
<p>Given that, a spell is just a series of instructions. Each one identifies which operation you want to perform. We can enumerate them:</p>
<p>^code instruction-enum</p>
<p>To encode a spell in data, we store an array of <code>enum</code> values. We've only got a few different primitives, so the range of <code>enum</code> values easily fits into a byte. This means the code for a spell is just a list of <span name="byte">bytes</span> -- ergo &quot;bytecode&quot;.</p>
<p><img src="images/bytecode-code.png" alt="A sequence of bytecode instructions: 0x00 HEALTH, 0x03 SOUND, 0x004 PARTICLES, ..." /></p>
<aside name="byte">
<p>Some bytecode VMs use more than a single byte for each instruction and have more complicated rules for how they are decoded. Actual machine code on common chips like x86 is a good bit more complex.</p>
<p>But a single byte is good enough for the <a href="http://en.wikipedia.org/wiki/Java_virtual_machine">Java Virtual Machine</a> and Microsoft's <a href="http://en.wikipedia.org/wiki/Common_Language_Runtime">Common Language Runtime</a>, which forms the backbone of the .NET platform, and it's good enough for us.</p>
</aside>
<p>To execute a single instruction, we see which primitive it is and dispatch to the right API method:</p>
<p>^code interpret-instruction</p>
<p>In this way, our interpreter forms the bridge between code world and data world. We can wrap this in a little VM that executes an entire spell like so:</p>
<p>^code vm</p>
<p>Type that in and you'll have written your first virtual machine. Unfortunately, it's not very flexible. We can't define a spell that touches the player's opponent or lowers a stat. We can only play one sound!</p>
<p>To get something that starts to have the expressive feel of an actual language, we need to get parameters in here.</p>
<h3 id="a-stack-machine">A stack machine</h3>
<p>To execute a complex nested expression, you start with the innermost subexpressions. You calculate those, and the results flow outward as arguments to the expressions that contain them until eventually, the whole expression has been evaluated.</p>
<p>The Interpreter pattern models this explicitly as a tree of nested objects, but we want the speed of a flat list of instructions. We still need to ensure results from subexpressions flow to the right surrounding expressions. But, since our data is flattened, we'll have to use the <em>order</em> of the instructions to control that. We'll do it the same way your CPU does -- <span name="stack-machine">with a stack</span>.</p>
<aside name="stack-machine">
<p>This architecture is unimaginatively called a <a href="http://en.wikipedia.org/wiki/Stack_machine"><em>stack machine</em></a>. Programming languages like <a href="http://en.wikipedia.org/wiki/Forth_(programming_language)">Forth</a>, <a href="http://en.wikipedia.org/wiki/PostScript">PostScript</a>, and <a href="http://en.wikipedia.org/wiki/Factor_(programming_language)">Factor</a> expose this model directly to the user.</p>
</aside>
<p>^code stack</p>
<p>The VM maintains an internal stack of values. In our example, the only kinds of values our instructions work with are numbers, so we can use a simple array of <code>int</code>s. Whenever a bit of data needs to work its way from one instruction to another, it gets there through the stack.</p>
<p>Like the name implies, values can be pushed onto or popped off of the stack, so let's add a couple of methods for that:</p>
<p>^code push-pop</p>
<p>When an instruction needs to receive parameters, it pops them off the stack like so:</p>
<p>^code pop-instructions</p>
<p>To get some values <em>onto</em> that stack, we need one more instruction: a literal. It represents a raw integer value. But where does <em>it</em> get its value from? How do we avoid some turtles-all-the-way-down infinite regress here?</p>
<p>The trick is to take advantage of the fact that our instruction stream is a sequence of bytes -- we can stuff the number directly in the byte array. We define another instruction type for a number literal like so:</p>
<p>^code interpret-literal</p>
<aside name="single">
<p>Here, I'm reading a single byte for the value to avoid the fiddly code required to decode a multiple-byte integer, but in a real implementation, you'll want to support literals that cover your full numeric range.</p>
</aside>
<p><img src="images/bytecode-literal.png" alt="Binary encoding of a literal instruction: 0x05 (LITERAL) followed by 123 (the value)." /></p>
<p>It reads the next <span name="single">byte</span> in the bytecode stream <em>as a number</em> and pushes it onto the stack.</p>
<p>Let's string a few of these instructions together and watch the interpreter execute them to get a feel for how the stack works. We start with an empty stack and the interpreter pointing to the first instruction:</p>
<p><img src="images/bytecode-stack-1.png" alt="Executing a bytecode sequence. The execution pointer points to the first literal instruction and the stack is empty." /></p>
<p>First, it executes the first <code>INST_LITERAL</code>. That reads the next byte from the bytecode (<code>0</code>) and pushes it onto the stack:</p>
<p><img src="images/bytecode-stack-2.png" alt="The next step. The literal 0 has been pushed onto the stack and the execution pointer is on the next literal." /></p>
<p>Then, it executes the second <code>INST_LITERAL</code>. That reads the <code>10</code> and pushes it:</p>
<p><img src="images/bytecode-stack-3.png" alt="The next step. Now 10 has been pushed onto the stack and the execution pointer is at the Health instruction." /></p>
<p>Finally, it executes <code>INST_SET_HEALTH</code>. That pops <code>10</code> and stores it in <code>amount</code>, then pops <code>0</code> and stores it in <code>wizard</code>. Then, it calls <code>setHealth()</code> with those parameters.</p>
<p>Ta-da! We've got a spell that sets the player's wizard's health to ten points. Now, we've got enough flexibility to define spells that set either wizard's stats to whatever amounts we want. We can also play different sounds and spawn particles.</p>
<p>But... this still feels like a <em>data</em> format. We can't, for example, raise a wizard's health by half of their wisdom. Our designers want to be able to express <em>rules</em> for spells, not just <em>values</em>.</p>
<h3 id="behavior-composition">Behavior = composition</h3>
<p>If we think of our little VM like a programming language, all it supports now is a couple of built-in functions and constant parameters for them. To get bytecode to feel like <em>behavior</em>, what we're missing is <em>composition</em>.</p>
<p>Our designers need to be able to create expressions that combine different values in interesting ways. For a simple example, they want spells that modify a stat <em>by</em> a certain amount instead of <em>to</em> a certain amount.</p>
<p>That requires taking into account a stat's current value. We have instructions for <em>writing</em> a stat, but we need to add a couple to <em>read</em> stats:</p>
<p>^code read-stats</p>
<p>As you can see, these work with the stack in both directions. They pop a parameter to determine which wizard to get the stat for, and then they look up the stat's value and push that back onto the stack.</p>
<p>This lets us write spells that copy stats around. We could create a spell that set a wizard's agility to their wisdom or a strange incantation that set one wizard's health to mirror his opponent's.</p>
<p>Better, but still quite limited. Next, we need arithmetic. It's time our baby VM learned how to add 1 + 1. We'll add a few more instructions. By now, you've probably got the hang of it and can guess how they look. I'll just show addition:</p>
<p>^code add</p>
<p>Like our other instructions, it pops a couple of values, does a bit of work, and then pushes the result back. Up until now, every new instruction gave us an incremental improvement in expressiveness, but we just made a big leap. It isn't obvious, but we can now handle all sorts of complicated, deeply nested arithmetic expressions.</p>
<p>Let's walk through a slightly more complex example. Say we want a spell that increases the player's wizard's health by the average of their agility and wisdom. In code, that's:</p>
<p>^code increase-health</p>
<p>You might think we'd need instructions to handle the explicit grouping that parentheses give you in the expression here, but the stack supports that implicitly. Here's how you could evaluate this by hand:</p>
<ol style="list-style-type: decimal">
<li>Get the wizard's current health and remember it.</li>
<li>Get the wizard's agility and remember it.</li>
<li>Do the same for their wisdom.</li>
<li>Get those last two, add them, and remember the result.</li>
<li>Divide that by two and remember the result.</li>
<li>Recall the wizard's health and add it to that result.</li>
<li>Take that result and set the wizard's health to that value.</li>
</ol>
<p>Do you see all of those &quot;remembers&quot; and &quot;recalls&quot;? Each &quot;remember&quot; corresponds to a push, and the &quot;recalls&quot; are pops. That means we can translate this to bytecode pretty easily. For example, the first line to get the wizard's current health is:</p>
<pre><code>:::text
LITERAL 0
GET_HEALTH</code></pre>
<p>This bit of bytecode pushes the wizard's health onto the stack. If we mechanically translate each line like that, we end up with a chunk of bytecode that evaluates our original expression. To give you a feel for how the instructions compose, I've done that below.</p>
<p>To show how the stack changes over time, we'll walk through a sample execution where the wizard's current stats are 45 health, 7 agility, and 11 wisdom. Next to each instruction is what the stack looks like after executing it and then a little comment explaining the instruction's purpose:</p>
<pre><code>:::text
LITERAL 0    [0]            # Wizard index
LITERAL 0    [0, 0]         # Wizard index
GET_HEALTH   [0, 45]        # getHealth()
LITERAL 0    [0, 45, 0]     # Wizard index
GET_AGILITY  [0, 45, 7]     # getAgility()
LITERAL 0    [0, 45, 7, 0]  # Wizard index
GET_WISDOM   [0, 45, 7, 11] # getWisdom()
ADD          [0, 45, 18]    # Add agility and wisdom
LITERAL 2    [0, 45, 18, 2] # Divisor
DIVIDE       [0, 45, 9]     # Average agility and wisdom
ADD          [0, 54]        # Add average to current health
SET_HEALTH   []             # Set health to result</code></pre>
<p>If you watch the stack at each step, you can see how data flows through it almost like <span name="threshold">magic</span>. We push <code>0</code> for the wizard index at the beginning, and it just hangs around at the bottom of the stack until we finally need it for the last <code>SET_HEALTH</code> at the end.</p>
<aside name="threshold">
<p>Maybe my threshold for &quot;magic&quot; is a little too low here.</p>
</aside>
<h3 id="a-virtual-machine">A virtual machine</h3>
<p>I could keep going, adding more and more instructions, but this is a good place to stop. As it is, we've got a nice little VM that lets us define fairly open-ended behavior using a simple, compact data format. While &quot;bytecode&quot; and &quot;virtual machines&quot; sound intimidating, you can see they're often as simple as a stack, a loop, and a switch statement.</p>
<p>Remember our original goal to have behavior be nicely sandboxed? Now that you've seen exactly how the VM is implemented, it's obvious that we've accomplished that. The bytecode can't do anything malicious or reach out into weird parts of the game engine because we've only defined a few instructions that touch the rest of the game.</p>
<p>We control how much memory it uses by how big of a stack we create, and we're careful to make sure it can't overflow that. We can even <span name="looping">control how much <em>time</em></span> it uses. In our instruction loop, we can track how many we've executed and bail out if it goes over some limit.</p>
<aside name="looping">
<p>Controlling execution time isn't necessary in our sample because we don't have any instructions for looping. We could limit execution time by limiting the total size of the bytecode. This also means our bytecode isn't Turing-complete.</p>
</aside>
<p>There's just one problem left: actually creating the bytecode. So far, we've taken bits of pseudocode and compiled them to bytecode by hand. Unless you've got a <em>lot</em> of free time, that's not going to work in practice.</p>
<h3 id="spellcasting-tools">Spellcasting tools</h3>
<p>One of our initial goals was to have a <em>higher</em>-level way to author behavior, but we've gone and created something <em>lower</em>-level than C++. It has the runtime performance and safety we want, but absolutely none of the designer-friendly usability.</p>
<p>To fill that gap, we need some tooling. We need a program that lets users define the high-level behavior of a spell and then takes that and generates the appropriate low-level stack machine bytecode.</p>
<p>That probably sounds way harder than making the VM. Many programmers were dragged through a compilers class in college and took away from it nothing but PTSD triggered by the sight of a <span name="dragon">book</span> with a dragon on the cover or the words &quot;<a href="http://en.wikipedia.org/wiki/Lex_(software)">lex</a>&quot; and &quot;<a href="http://en.wikipedia.org/wiki/Yacc">yacc</a>”.</p>
<aside name="dragon">
<p>I'm referring, of course, to the classic text <a href="http://en.wikipedia.org/wiki/Compilers:_Principles,_Tech%20niques,_and_Tools"><em>Compilers: Principles, Techniques, and Tools</em></a>.</p>
</aside>
<p>In truth, compiling a text-based language isn't that bad, though it's a <em>bit</em> too broad of a topic to cram in here. However, you don't have to do that. What I said we need is a <em>tool</em> -- it doesn't have to be a <em>compiler</em> whose input format is a <em>text file</em>.</p>
<p>On the contrary, I encourage you to consider building a graphical interface to let users define their behavior, especially if the people using it won't be highly technical. Writing text that's free of syntax errors is difficult for people who haven't spent years getting used to a compiler yelling at them.</p>
<p>Instead, you can build an app that lets users &quot;script&quot; by clicking and dragging little boxes, pulling down menu items, or whatever else makes sense for the kind of behavior you want them to create.</p>
<p><span name="text"></span></p>
<p><img src="images/bytecode-ui.png" alt="A mock-up of a little tree-based UI for authoring behavior." /></p>
<aside name="text">
<p>The scripting system I wrote for <a href="http://en.wikipedia.org/wiki/Henry_Hatsworth_in_the_Puzzling_Adventure">Henry Hatsworth in the Puzzling Adventure</a> worked like this.</p>
</aside>
<p>The nice thing about this is that your UI can make it impossible for users to create <span name="errors">&quot;invalid&quot;</span> programs. Instead of vomiting error messages on them, you can proactively disable buttons or provide default values to ensure that the thing they've created is valid at all points in time.</p>
<aside name="errors">
<p>I want to stress how important error-handling is. As programmers, we tend to view human error as a shameful personality flaw that we strive to eliminate in ourselves.</p>
<p>To make a system that users enjoy, you have to embrace their humanity, <em>including their fallibility</em>. Making mistakes is what people do, and is a fundamental part of the creative process. Handling them gracefully with features like undo helps your users be more creative and create better work.</p>
</aside>
<p>This spares you from designing a grammar and writing a parser for a little language. But, I know, some of you find UI programming equally unpleasant. Well, in that case, I don't have any good news for you.</p>
<p>Ultimately, this pattern is about expressing behavior in a user-friendly, high-level way. You have to craft the user experience. To execute the behavior efficiently, you then need to translate that into a lower-level form. It is real work, but if you're up to the challenge, it can pay off.</p>
<h2 id="design-decisions">Design Decisions</h2>
<p>I <span name="failed">tried</span> to keep this chapter as simple as I could, but what we're really doing is creating a language. That's a pretty open-ended design space. Exploring it can be tons of fun, so make sure you don't forget to finish your game.</p>
<aside name="failed">
<p>Since this is the longest chapter in the book, it seems I failed that task.</p>
</aside>
<h3 id="how-do-instructions-access-the-stack">How do instructions access the stack?</h3>
<p>Bytecode VMs come in two main flavors: stack-based and register-based. In a stack-based VM, instructions always work from the top of the stack, like in our sample code. For example, <code>INST_ADD</code> pops two values, adds them, and pushes the result.</p>
<p>Register-based VMs still have a stack. The only difference is that instructions can read their inputs from deeper in the stack. Instead of <code>INST_ADD</code> always <em>popping</em> its operands, it has two indexes stored in the bytecode that identify where in the stack to read the operands from.</p>
<ul>
<li><p><strong>With a stack-based VM:</strong></p>
<ul>
<li><p><em>Instructions are small.</em> Since each instruction implicitly finds its arguments on top of the stack, you don't need to encode any data for that. This means each instruction can be pretty small, usually a single byte.</p></li>
<li><p><em>Code generation is simpler.</em> When you get around to writing the compiler or tool that outputs bytecode, you'll find it simpler to generate stack-based bytecode. Since each instruction implicitly works from the top of the stack, you just need to output instructions in the right order to pass parameters between them.</p></li>
<li><p><em>You have more instructions.</em> Each instruction only sees the very top of the stack. This means that to generate code for something like <code>a = b + c</code>, you need separate instructions to move <code>b</code> and <code>c</code> to the top of the stack, perform the operation, then move the result into <code>a</code>.</p></li>
</ul></li>
<li><p><strong>With a register-based VM:</strong></p>
<ul>
<li><p><em>Instructions are larger.</em> Since instructions need arguments for stack offsets, a single instruction needs more bits. For example, an instruction in <span name="lua">Lua</span> -- probably the most well-known register-based VM -- is a full 32-bits. It uses 6 bits for the instruction type, and the rest are arguments.</p>
<aside name="lua">
<p>The Lua folks don't specify Lua's bytecode format, and it changes from version to version. What I'm describing here is true as of Lua 5.1. For an absolutely amazing deep dive into Lua's internals, read <a href="http://lu%20aforge.net/docman/83/98/ANoFrillsIntroToLua51VMInstructions.pdf">this</a>.</p>
</aside></li>
<li><p><em>You have fewer instructions.</em> Since each instruction can do more work, you don't need as many of them. Some say you get a performance improvement since you don't have to shuffle values around in the stack as much.</p></li>
</ul></li>
</ul>
<p>So which should you do? My recommendation is to stick with a stack-based VM. They're simpler to implement and much simpler to generate code for. Register-based VMs got a reputation for being a bit faster after Lua converted to that style, but it depends <em>deeply</em> on your actual instructions and on lots of other details of your VM.</p>
<h3 id="what-instructions-do-you-have">What instructions do you have?</h3>
<p>Your instruction set defines the boundaries of what can and cannot be expressed in bytecode, and it also has a big impact on the performance of your VM. Here's a laundry list of the different kinds of instructions you may want:</p>
<ul>
<li><p><strong>External primitives.</strong> These are the ones that reach out of the VM into the rest of the game engine and do stuff that the user can see. They control what kinds of real behavior can be expressed in bytecode. Without these, your VM can't do anything more than burn CPU cycles.</p></li>
<li><p><strong>Internal primitives.</strong> These manipulate values inside the VM -- things like literals, arithmetic, comparison operators, and instructions that juggle the stack around.</p></li>
<li><p><strong>Control flow.</strong> Our example didn't cover these, but when you want behavior that's imperative and conditionally executes instructions or loops and executes instructions more than once, you need control flow. In the low-level language of bytecode, they're surprisingly simple: jumps.</p>
<p>In our instruction loop, we had an index to track where we were in the bytecode. All a jump instruction does is modify that variable and change where we're currently executing. In other words, it's a <code>goto</code>. You can build all kinds of higher-level control flow using that.</p></li>
<li><p><strong>Abstraction.</strong> If your users start defining a <em>lot</em> of stuff in data, eventually they'll want to start reusing bits of bytecode instead of having to copy and paste it. You may want something like callable procedures.</p>
<p>In their simplest form, procedures aren't much more complex than a jump. The only difference is that the VM maintains a second <em>return</em> stack. When it executes a &quot;call&quot; instruction, it pushes the current instruction index onto the return stack and then jumps to the called bytecode. When it hits a &quot;return&quot;, the VM pops the index from the return stack and jumps back to it.</p></li>
</ul>
<h3 id="how-are-values-represented">How are values represented?</h3>
<p>Our sample VM only works with one kind of value, integers. That makes answering this easy -- the stack is just a stack of <code>int</code>s. A more full-featured VM will support different data types: strings, objects, lists, etc. You'll have to decide how those are stored internally.</p>
<ul>
<li><p><strong>A single datatype:</strong></p>
<ul>
<li><p><em>It's simple.</em> You don't have to worry about tagging, conversions, or type-checking.</p></li>
<li><p><em>You can't work with different data types.</em> This is the obvious downside. Cramming different types into a single representation -- think storing numbers as strings -- is asking for pain.</p></li>
</ul></li>
<li><p><strong>A tagged variant:</strong></p>
<p>This is the common representation for dynamically typed languages. Every value has two pieces. The first is a type tag -- an <code>enum</code> -- that identifies what data type is being stored. The rest of the bits are then interpreted appropriately according to that type, like:</p>
<p>^code tagged-value</p>
<ul>
<li><p><em>Values know their type.</em> The nice thing about this representation is that you can check the type of a value at runtime. That's important for dynamic dispatch and for ensuring that you don't try to perform operations on types that don't support it.</p></li>
<li><p><em>It takes more memory.</em> Every value has to carry around a few extra bits with it to identify its type. In something as low-level as a VM, a few bits here and there add up quickly.</p></li>
</ul></li>
<li><p><strong>An untagged union:</strong></p>
<p>This uses a union like the previous form, but it does <em>not</em> have a type tag that goes along with it. You have a little blob of bits that could represent more than one type, and it's up to you to ensure you don't misinterpret them.</p>
<p>This is how <span name="untyped">statically typed</span> languages represent things in memory. Since the type system ensures at compile time that you aren't misinterpreting values, you don't need to validate it at runtime.</p>
<aside name="untyped">
<p>This is also how <em>untyped</em> languages like assembly and Forth store values. Those languages leave it to the <em>user</em> to make sure they don't write code that misinterprets a value's type. Not for the faint of heart!</p>
</aside>
<ul>
<li><p><em>It's compact.</em> You can't get any more efficient than storing just the bits you need for the value itself.</p></li>
<li><p><em>It's fast.</em> Not having type tags implies you're not spending cycles checking them at runtime either. This is one of the reasons statically typed languages tend to be faster than dynamic ones.</p></li>
<li><p><em>It's unsafe.</em> <span name="unsafe">This</span> is the real cost, of course. A bad chunk of bytecode that causes you to misinterpret a value and treat a number like a pointer or vice versa can violate the security of your game or make it crash.</p>
<aside name="unsafe">
<p>If your bytecode was compiled from a statically typed language, you might think you're safe here because the compiler won't generate unsafe bytecode. That may be true, but remember that malicious users may hand-craft evil bytecode without going through your compiler.</p>
<p>That's why, for example, the Java Virtual Machine has to do <em>bytecode verification</em> when it loads a program.</p>
</aside></li>
</ul></li>
<li><p><strong>An interface:</strong></p>
<p>The object-oriented solution for a value that maybe be one of several different types is through polymorphism. An interface provides virtual methods for the various type tests and conversions, along the lines of:</p>
<p>^code value-interface</p>
<p>Then you have concrete classes for each specific data type, like:</p>
<p>^code int-value</p>
<ul>
<li><p><em>It's open-ended.</em> You can define new value types outside of the core VM as long as they implement the base interface.</p></li>
<li><p><em>It's object-oriented.</em> If you adhere to OOP principles, this does things the &quot;right&quot; way and uses polymorphic dispatch for type-specific behavior instead of something like switching on a type tag.</p></li>
<li><p><em>It's verbose.</em> You have to define a separate class with all of the associated ceremonial verbiage for each data type. Note that in the previous examples, we showed the entire definition of <em>all</em> of the value types. Here, we only cover one!</p></li>
<li><p><em>It's inefficient.</em> To get polymorphism, you have to go through a pointer, which means even tiny values like Booleans and numbers get wrapped in objects that are allocated on the heap. Every time you touch a value, you have to do a virtual method call.</p>
<p>In something like the core of a virtual machine, small performance hits like this quickly add up. In fact, this suffers from many of the problems that caused us to avoid the Interpreter pattern, except now the problem is in our <em>values</em> instead of our <em>code</em>.</p></li>
</ul></li>
</ul>
<p>My recommendation is that if you can stick with a single data type, do that. Otherwise, do a tagged union. That's what almost every language interpreter in the world does.</p>
<h3 id="how-is-the-bytecode-generated">How is the bytecode generated?</h3>
<p>I saved the most important question for last. I've walked you through the code to <em>consume</em> and <em>interpret</em> bytecode, but it's up to you to build something to <em>produce</em> it. The typical solution here is to write a compiler, but it's not the only option.</p>
<ul>
<li><p><strong>If you define a text-based language:</strong></p>
<ul>
<li><p><em>You have to define a syntax.</em> Both amateur and professional language designers categorically underestimate how difficult this is to do. Defining a grammar that makes parsers happy is easy. Defining one that makes <em>users</em> happy is <em>hard</em>.</p>
<p>Syntax design is user interface design, and that process doesn't get easier when you constrain the user interface to a string of characters.</p></li>
<li><p><em>You have to implement a parser.</em> Despite their reputation, this part is pretty easy. Either use a parser generator like ANTLR or Bison, or -- like I do -- hand-roll a little recursive descent one, and you're good to go.</p></li>
<li><p><em>You have to handle syntax errors.</em> This is one of the most important and most difficult parts of the process. When users make syntax and semantic errors -- which they will, constantly -- it's your job to guide them back onto the right path. Giving helpful feedback isn't easy when all you know is that your parser is sitting on some unexpected punctuation.</p></li>
<li><p><em>It will likely turn off non-technical users.</em> We programmers like text files. Combined with powerful command-line tools, we think of them as the LEGO blocks of computing -- simple, but easily composable in a million ways.</p>
<p>Most non-programmers don't think of plaintext like that. To them, text files feel like filling in tax forms for an angry robotic auditor that yells at them if they forget a single semicolon.</p></li>
</ul></li>
<li><p><strong>If you define a graphical authoring tool:</strong></p>
<ul>
<li><p><em>You have to implement a user interface.</em> Buttons, clicks, drags, stuff like that. Some cringe at the idea of this, but I personally love it. If you go down this route, it's important to treat designing the user interface as a core part of doing your job well -- not just an unpleasant task to be muddled through.</p>
<p>Every little bit of extra work you do here will make your tool easier and more pleasant to use, and that directly leads to better content in your game. If you look behind many of the games you love, you'll often find the secret was fun authoring tools.</p></li>
<li><p><em>You have fewer error cases.</em> Because the user is building behavior interactively one step at a time, your application can guide them away from mistakes as soon as they happen.</p>
<p>With a text-based language, the tool doesn't see <em>any</em> of the user's content until they throw an entire file at it. That makes it harder to prevent and handle errors.</p></li>
<li><p><em>Portability is harder.</em> The nice thing about text compilers is that text files are <span name="lines">universal</span>. A simple compiler just reads in one file and writes one out. Porting that across operating systems is trivial.</p>
<aside name="lines">
<p>Except for line endings. And encodings.</p>
</aside>
<p>When you're building a UI, you have to choose which framework to use, and many of those are specific to one OS. There are cross-platform UI toolkits too, but those often get ubiquity at the expense of familiarity -- they feel equally foreign on all of platforms.</p></li>
</ul></li>
</ul>
<h2 id="see-also">See Also</h2>
<ul>
<li><p>This pattern's close sister is the Gang of Four's <a
href="http://en.wikipedia.org/wiki/Interpreter_pattern"
class="gof-pattern">Interpreter</a> pattern. Both give you a way to express composable behavior in terms of data.</p>
<p>In fact, you'll often end up using <em>both</em> patterns. The tool you use to generate bytecode will have an internal tree of objects that represents the code. This is exactly what the Interpreter pattern expects.</p>
<p>In order to compile that to bytecode, you'll recursively walk the tree, just like you do to interpret it with the Interpreter pattern. The <em>only</em> difference is that instead of executing a primitive piece of behavior immediately, you output the bytecode instruction to perform that later.</p></li>
<li><p>The <a href="http://www.lua.org/">Lua</a> programming language is the most widely used scripting language in games. It's implemented internally as a very compact register-based bytecode VM.</p></li>
<li><p><a href="http://en.wikipedia.org/wiki/UnrealEd#Kismet">Kismet</a> is a graphical scripting tool built into UnrealEd, the editor for the Unreal engine.</p></li>
<li><p>My own little scripting language, <a href="https://github.com/munificent/wren">Wren</a>, is a simple stack-based bytecode interpreter.</p></li>
</ul>
